const std = @import("std");
const atomic = std.atomic;
const os = std.os;
const c = @import("../c.zig");
const Writer = @import("logd/Writer.zig");

var writer_blocking: Writer = .{ .blocking = true };
var writer_nonblocking: Writer = .{ .blocking = false };

pub fn logdClose() callconv(.C) void {
    writer_blocking.close();
    writer_nonblocking.close();
}

pub fn logdWrite(
    log_id: c.log_id_t,
    ts: *os.timespec,
    vec: [*]os.iovec,
    nr: usize,
) callconv(.C) c_int {
    var buf: [@sizeOf(os.iovec) * 8]u8 = undefined;
    var fba = std.heap.FixedBufferAllocator.init(&buf);
    const gpa = fba.allocator();
    const s = struct {
        var dropped = atomic.Value(usize).init(0);
    };
    var new_vec = gpa.alloc(os.iovec_const, nr + 1) catch
        return -1;
    @memset(new_vec, std.mem.zeroes(os.iovec_const));
    var writer: *Writer = switch (log_id) {
        c.LOG_ID_SECURITY => &writer_blocking,
        else => &writer_nonblocking,
    };
    writer.open() catch return @intFromEnum(os.E.BADF);
    // ignore log messages we send to ourself (logd).
    // Such log messages are often generated by libraries
    // we depend on which use standard Android logging.
    if (os.linux.getuid() == c.AID_LOGD) return 0;
    var header: c.android_log_header_t = .{
        .tid = @intCast(os.linux.gettid()),
        .realtime = .{
            .tv_sec = @intCast(ts.tv_sec),
            .tv_nsec = @intCast(ts.tv_nsec),
        },
    };
    new_vec[0] = os.iovec_const{
        .iov_base = @ptrCast(&header),
        .iov_len = @sizeOf(@TypeOf(header)),
    };
    const snapshot = s.dropped.swap(0, .Monotonic);
    const loggable_len = c.__android_log_is_loggable_len(
        c.ANDROID_LOG_INFO,
        "liblog",
        "liblog".len,
        c.ANDROID_LOG_VERBOSE,
    );
    if (snapshot > 0 and loggable_len > 0) {
        header.id = c.LOG_ID_EVENTS;
        var buffer: c.android_log_event_int_t = .{
            .header = .{ .tag = c.LIBLOG_LOG_TAG },
            .payload = .{
                .type = c.EVENT_TYPE_INT,
                .data = @intCast(snapshot),
            },
        };
        new_vec[1] = .{
            .iov_base = @ptrCast(&buffer),
            .iov_len = @sizeOf(@TypeOf(buffer)),
        };
        const amt = writer.writev(new_vec[0..2]) catch 0;
        const header_size = @sizeOf(@TypeOf(header));
        const buffer_size = @sizeOf(@TypeOf(buffer));
        if (amt != header_size + buffer_size) {
            _ = s.dropped.fetchAdd(snapshot, .Monotonic);
        }
    }

    header.id = @intCast(log_id);
    var i: usize = 1;
    var size: usize = 0;
    while (i < nr + 1) : (i += 1) {
        new_vec[i].iov_base = vec[i - 1].iov_base;
        size += vec[i - 1].iov_len;
        new_vec[i].iov_len = vec[i - 1].iov_len;
        if (size > c.LOGGER_ENTRY_MAX_PAYLOAD) {
            const len = size - c.LOGGER_ENTRY_MAX_PAYLOAD;
            new_vec[i].iov_len -= len;
            if (new_vec[i].iov_len > 0) i += 1;
            break;
        }
    }

    // EAGAIN occurs if logd is overloaded, other errors
    // indicate that something went wrong with the connection,
    // so we reset it and try again.
    _ = writer.writev(new_vec[0..i]) catch |err| switch (err) {
        else => {
            writer.reconnect() catch {
                _ = s.dropped.fetchAdd(1, .Monotonic);
                return -1;
            };
            _ = writer.writev(new_vec[0..i]) catch {
                _ = s.dropped.fetchAdd(1, .Monotonic);
                return -1;
            };
        },
        error.WouldBlock => {
            _ = s.dropped.fetchAdd(1, .Monotonic);
            return -1;
        },
    };
    return 0;
}
